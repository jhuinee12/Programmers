> 최초작성 : 2022.10.11

## ******Level2 - 멀리 뛰기****(kotlin)**

 [코딩테스트 연습 - 멀리 뛰기](hhttps://school.programmers.co.kr/learn/courses/30/lessons/12914)

### 문제 설명
효진이는 멀리 뛰기를 연습하고 있습니다. 효진이는 한번에 1칸, 또는 2칸을 뛸 수 있습니다. 칸이 총 4개 있을 때, 효진이는

(1칸, 1칸, 1칸, 1칸) <br>
(1칸, 2칸, 1칸) <br>
(1칸, 1칸, 2칸) <br>
(2칸, 1칸, 1칸) <br>
(2칸, 2칸)

의 5가지 방법으로 맨 끝 칸에 도달할 수 있습니다. <br>
멀리뛰기에 사용될 칸의 수 n이 주어질 때, 효진이가 끝에 도달하는 방법이 몇 가지인지 알아내, 여기에 1234567를 나눈 나머지를 리턴하는 함수, solution을 완성하세요. 예를 들어 4가 입력된다면, 5를 return하면 됩니다.

### 제한 조건
	• n은 1 이상, 2000 이하인 정수입니다.

### **​입출력 예** 
| n | return |
|---|--------|
| 4 | 5      |
| 3 | 3      |

#### **입출력 예**

##### 입출력 예 #1
위에서 설명한 내용과 같습니다.

##### 입출력 예 #2
(2칸, 1칸) <br>
(1칸, 2칸) <br>
(1칸, 1칸, 1칸) <br>
총 3가지 방법으로 멀리 뛸 수 있습니다.

---

### _**나의 풀이**_

1\. 규칙을 정리해봤을 때 값은 피보나치 수열처럼 커진다.

2\. 1 -> 2 -> 3 -> 5 -> 8 -> ...

3\. 위 규칙을 만족하도록 queue를 통해 구현하였고, 오버플로우가 되지 않도록 add할 때 % 1234567L을 해주었다.

```kt
class Solution {
    fun solution(n: Int): Long {
        val queue = ArrayDeque<Long>()

        for (i in 0L until n) {
            when (i) {
                0L -> queue.add(1L)
                1L -> queue.add(2L)
                2L -> queue.add(3L)
                else -> {
                    queue.removeFirst()
                    queue.add((queue[0] + queue[1]) % 1234567L)
                }
            }
        }

        return queue.last()
    }
}
```

###### 오버플로우에서 많이 애먹었다.
###### 7번부터 오버플로우가 나서 '2000'을 입력하고 돌려봤더니 -의 값이 나왔다.
###### 그래서 1234567로 나눈 나머지를 넣었구나.. 깨달았다 ㅋㅋㅋㅋㅋ
###### 원래는 리턴할 때 나눴었는데, 더하고 나누나, 나누고 더하나 똑같다는 것을 알았다.